crystal_doc_search_index_callback({"repository_name":"","body":"# agent\n\nAn Agent is a wrapper that makes it thread-safe to share object references\nacross your application, without having to worry about concurrent access and destructive assignment.\n\nIt's an ideal companion for immutable data structures, but promises thread-safe access\nand modifications on mutable objects, too, provided that the user only manipulates state\nwithin an Agent's methods.\n\n## Installation\n\n- Add the dependency to your `shard.yml`:\n\n```yaml\ndependencies:\n  agent:\n    github: lbarasti/agent\n```\n\n- Run `shards install`\n\n## Usage\n\nLet's define an Agent wrapping a hash.\n```crystal\nrequire \"agent\"\n\nconcurrent_hash = Agent.new({\"a\" => 1, \"c\" => 41})\n```\n\nWe can now traverse the hash safely with `Agent.get`.\n```crystal\nconcurrent_hash.get { |h| h[\"a\"] } # => 1\n```\nEverything we do within the block passed to `Agent#get` is guaranteed to be thread-safe and consistent.\n\nTo update the hash in a thread-safe fashion we call `Agent#update`.\n```crystal\nconcurrent_hash.update { |h|\n  h[\"b\"] = 12\n  h\n} # => Agent::Result::Submitted\n```\nThe block passed to `Agent#update` will run asynchornously, but any calls following\nit are guaranteed to see the updated version of the wrapped object - provided that the update was successfull.\n\n```crystal\nconcurrent_hash.get { |h| h[\"b\"] } # => 12\n```\n\nIf you want synchronously fetch and update the state of the agent, then `Agent#get_and_update` will serve your purpose.\n\n```crystal\nconcurrent_hash.get_and_update { |h|\n  old_b = h[\"b\"]\n  h[\"b\"] = old_b + 1\n  {h[\"b\"] , h}\n} # => 13\n```\n\n`Agent#get_and_update` expects a block of type\n```crystal\nHash(String, Int32) -> {Q, Hash(String, Int32)}\n```\nwhere `Q` is a generic type and is the type of the returned value. This means you can return\nany transformation of the current Agent's state *and* alter the state in a single pass.\n\n### Error handling and timeouts\n\nErrors are handled within the Agent, and surfaced as `Agent::Result::Error` values.\nFor example, if we try to fetch a value for a non existing key, the `KeyError` exception turns into an `Agent::Result::Error`.\n```crystal\nconcurrent_hash.get { |h| h[\"non-existing\"] } # => Agent::Result::Error\n```\nIf you'd rather deal with the exception yourself, check out the `!` variant of Agent's getter methods.\n```crystal\nconcurrent_hash.get! { |h| h[\"non-existing\"] } # raises Exception(\"Error\")\n```\n\nIn order to give responsiveness guarantees to the client's code, Agent's operations support timing out.\nThe default timeout is 5 seconds, but you can pass a custom timeout on each operation.\n\n```crystal\nconcurrent_hash.get {\n  sleep 3.seconds # simulates a time consuming operation\n}\n\nconcurrent_hash.get(max_wait: 1.second) { |h|\n  h[\"b\"]\n} # => Agent::Result::Timeout\n\nconcurrent_hash.get!(max_wait: 1.second) { |h|\n  h[\"b\"]\n} # raises Exception(\"Timeout\")\n```\n\n## Agents in multi-threaded runtime\n\nAs of Crystal 0.34.0, by default, your code will be compiled to run on a single thread.\nIn this scenario, using Agents still makes sense if you access or modify objects from\ndifferent fibers. If that's not the case, then the only perk of adopting Agents is that\nyour code will be future proof.\n\nTo see how multi-threading and concurrency can break the correctness of your application,\nthink about the behaviour of the following code, where we spawn 10 fibers, and each one\nconcurrently updates the value of a counter 1024 times.\n\n```crystal\ndone = Channel(Nil).new(10)\ncounter = 0\n(1..10).each {\n  spawn {\n    (1..1024).each {\n      counter += 1\n    }\n    done.send nil\n  }\n}\n10.times { done.receive }\nputs counter # => ?\n```\n\nOr just check out this repository and run\n\n```\ncrystal build -Dpreview_mt examples/breaking_counter.cr\nCRYSTAL_WORKERS=4 ./breaking_counter\n```\n\nYou'll notice unpredictable results in the final count.\n\nWe can fix this with an `Agent`.\n\n```crystal\ndone = Channel(Nil).new(10)\ncounter = Agent.new(0)\n\n(1..10).each {\n  spawn {\n    (1..1024).each {\n      counter.update { |x| x + 1 }\n    }\n    done.send nil\n  }\n}\n10.times { done.receive }\nputs counter.get # => 1024 * 10\n```\n\nNow the final value for `counter` will *always* equal 10240, no matter the number of runtime threads.\n\n## FAQ\n\n### How does this differ from `Atomic(T)` ([docs](https://crystal-lang.org/api/latest/Atomic.html))?\n\nOnly primitive integer types, reference types or nilable reference types can be used with an Atomic type.  \nOn the other hand, you can wrap any type in an `Agent`.\n\n### Are Agent updates atomic, i.e. do either all the instructions in a block take effect or none of it does?\n\nNo, atomicity is not guaranteed. In particular, if an exception is raised within a given get / update block,\nthen any side-effecting operation preceeding the exception will not be reverted.\n\nRelying on immutable data structures and avoiding side-effects in Agent's get / update operations are\ngood mitigations for the lack of atomicity.\n\n### My code uses immutable data structures such as [these ones](https://github.com/lucaong/immutable). Are these not thread-safe by definition?\n\nImmutable data structures are thread-safe in the sense that you can safely access them from different fibers, but they are subject to the so-called [lost update problem](https://en.wikipedia.org/wiki/Concurrency_control#Why_is_concurrency_control_needed?), where changes made by a fiber will not be recorded by another one - think of the case where multiple fibers close over the same variable, and then destructively assign values to such variable, concurrently. \n\nYou can dodge the lost-update bullet by making sure that all the updates to your immutable data structure happen in a single fiber, but that's not always possible or desirable. Furthermore, you might still have to implement custom logic to ensure transactionality - think of the scenario where a fiber wants to increment a counter by 1, but first has to fetch the current value of the counter. In a parallel¹ execution, the counter _might_ change between the fetch and the set statement\n\n¹ Things will be fine in a concurrent but not parallel execution, as the fiber will not yield control until after the update.\n\n## Development\n\nJust check out the repository and run `crystal spec` to run the tests.\n\n## Contributing\n\n1. Fork it (<https://github.com/lbarasti/agent/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [lbarasti](https://github.com/lbarasti) - creator and maintainer\n","program":{"html_id":"/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"/Agent","path":"Agent.html","kind":"class","full_name":"Agent(T)","name":"Agent","abstract":false,"superclass":{"html_id":"/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"DefaultTimeout","name":"DefaultTimeout","value":"5.seconds","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(state:T)-class-method","html_id":"new(state:T)-class-method","name":"new","doc":"Creates an Agent wrapping `@state`.\n\nAgents are fiber-based, i.e. each Agent runs a fiber and serialises\naccess and update requests over a channel. This guarantees thread-safety and\ndata consistency within Agent's operations.","summary":"<p>Creates an Agent wrapping <code>@state</code>.</p>","abstract":false,"args":[{"name":"state","doc":null,"default_value":"","external_name":"state","restriction":"T"}],"args_string":"(state : T)","source_link":null,"def":{"name":"new","args":[{"name":"state","doc":null,"default_value":"","external_name":"state","restriction":"T"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Agent(T).allocate\n_.initialize(state)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"get(max_time=DefaultTimeout):T|Result-instance-method","html_id":"get(max_time=DefaultTimeout):T|Result-instance-method","name":"get","doc":"Fetches the state of the Agent.\n\nThis is equivalent to `get(max_time, &id)`, where `id` is the identity function.","summary":"<p>Fetches the state of the Agent.</p>","abstract":false,"args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"args_string":"(max_time = <span class=\"t\">DefaultTimeout</span>) : T | Result","source_link":null,"def":{"name":"get","args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"T | Result","visibility":"Public","body":"get(max_time) do |v|\n  v\nend"}},{"id":"get(max_time=DefaultTimeout,&fn:T->Q):Q|ResultforallQ-instance-method","html_id":"get(max_time=DefaultTimeout,&amp;fn:T-&gt;Q):Q|ResultforallQ-instance-method","name":"get","doc":"Fetches the state of the Agent and applies the given function to it.\n\nThis is equivalent to calling `Agent#get_and_update`, where `fn` does not update the current state.\nthe current state.","summary":"<p>Fetches the state of the Agent and applies the given function to it.</p>","abstract":false,"args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"args_string":"(max_time = <span class=\"t\">DefaultTimeout</span>, &fn : T -> Q) : Q | Result forall Q","source_link":null,"def":{"name":"get","args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"fn","doc":null,"default_value":"","external_name":"fn","restriction":"(T -> Q)"},"return_type":"Q | Result","visibility":"Public","body":"get_and_update(max_time) do |state|\n  {fn.call(state), state}\nend"}},{"id":"get!(max_time=DefaultTimeout):T-instance-method","html_id":"get!(max_time=DefaultTimeout):T-instance-method","name":"get!","doc":"Fetches the state of the Agent.\n\nAnalogous `Agent#get`, but an exception is raised in case of timeout.\nNOTE the compile-time type of the returned value is `T`, rather than `T | Agent::Result`.","summary":"<p>Fetches the state of the Agent.</p>","abstract":false,"args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"args_string":"(max_time = <span class=\"t\">DefaultTimeout</span>) : T","source_link":null,"def":{"name":"get!","args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"T","visibility":"Public","body":"case r = get(max_time)\nwhen T\n  r\nelse\n  raise(Exception.new(r.to_s))\nend"}},{"id":"get!(max_time=DefaultTimeout,&fn:T->Q):QforallQ-instance-method","html_id":"get!(max_time=DefaultTimeout,&amp;fn:T-&gt;Q):QforallQ-instance-method","name":"get!","doc":"Fetches the state of the Agent and applies the given function to it.\n\nAnalogous `Agent#get`, but an exception is raised in case of timeout\nor if an exception is raised within the block.\nNOTE the compile-time type of the returned value is `Q`, rather than `Q | Agent::Result`.","summary":"<p>Fetches the state of the Agent and applies the given function to it.</p>","abstract":false,"args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"args_string":"(max_time = <span class=\"t\">DefaultTimeout</span>, &fn : T -> Q) : Q forall Q","source_link":null,"def":{"name":"get!","args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"fn","doc":null,"default_value":"","external_name":"fn","restriction":"(T -> Q)"},"return_type":"Q","visibility":"Public","body":"case r = get(max_time, &fn)\nwhen Q\n  r\nelse\n  raise(Exception.new(r.to_s))\nend"}},{"id":"get_and_update(max_time=DefaultTimeout,&fn:T->::Tuple(Q,T)):Q|ResultforallQ-instance-method","html_id":"get_and_update(max_time=DefaultTimeout,&amp;fn:T-&gt;::Tuple(Q,T)):Q|ResultforallQ-instance-method","name":"get_and_update","doc":"Fetches the state of the Agent, updates it and returns the first projection of `fn.call(state)`.\n\nIf the `#get_and_update` request is not handled by the Agent's fiber within\n`max_time`, then an Agent::Result::Timeout is returned. If an error is raised\nduring the execution of the block, then an Agent::Result::Error is returned.\nOtherwise, the transformed state `fn.call(state).first`, and the state is updated to\n`fn.call(state).last`.","summary":"<p>Fetches the state of the Agent, updates it and returns the first projection of <code>fn.call(state)</code>.</p>","abstract":false,"args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"args_string":"(max_time = <span class=\"t\">DefaultTimeout</span>, &fn : T -> ::Tuple(Q, T)) : Q | Result forall Q","source_link":null,"def":{"name":"get_and_update","args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"fn","doc":null,"default_value":"","external_name":"fn","restriction":"(T -> ::Tuple(Q, T))"},"return_type":"Q | Result","visibility":"Public","body":"ack = Channel(Nil).new\nselect\nwhen @commands.send(Wait.new(ack))\n  ack.receive\n  begin\n    q, @state = fn.call(@state)\n    q\n  rescue\n    Result::Error\n  ensure\n    ack.send(nil)\n  end\nwhen timeout(max_time)\n  Result::Timeout\nend\n\n"}},{"id":"get_and_update!(max_time=DefaultTimeout,&fn:T->::Tuple(Q,T)):QforallQ-instance-method","html_id":"get_and_update!(max_time=DefaultTimeout,&amp;fn:T-&gt;::Tuple(Q,T)):QforallQ-instance-method","name":"get_and_update!","doc":"Fetches the state of the Agent, updates it and returns the first projection of `fn.call(state)`.\n\nAnalogous `Agent#get_and_update`, but an exception is raised in case of timeout\nor if an exception is raised within the block.\nNOTE the compile-time type of the returned value is `Q`, rather than `Q | Agent::Result`.","summary":"<p>Fetches the state of the Agent, updates it and returns the first projection of <code>fn.call(state)</code>.</p>","abstract":false,"args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"args_string":"(max_time = <span class=\"t\">DefaultTimeout</span>, &fn : T -> ::Tuple(Q, T)) : Q forall Q","source_link":null,"def":{"name":"get_and_update!","args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"fn","doc":null,"default_value":"","external_name":"fn","restriction":"(T -> ::Tuple(Q, T))"},"return_type":"Q","visibility":"Public","body":"case r = get_and_update(max_time, &fn)\nwhen Q\n  r\nelse\n  raise(Exception.new(r.to_s))\nend"}},{"id":"update(max_time=DefaultTimeout,&fn:T->T):Result-instance-method","html_id":"update(max_time=DefaultTimeout,&amp;fn:T-&gt;T):Result-instance-method","name":"update","doc":"Updates the state of the Agent.\n\nReturns `Agent::Result::Submitted`, if the update operation was accepted.\nReturns `Agent::Result::Timeout`, if a timeout is triggered before the operation\nis accepted by the Agent's fiber.\nNOTE `#update` does not wait for `fn` to be applied to the Agent's state\nbefore returning.","summary":"<p>Updates the state of the Agent.</p>","abstract":false,"args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"args_string":"(max_time = <span class=\"t\">DefaultTimeout</span>, &fn : T -> T) : Result","source_link":null,"def":{"name":"update","args":[{"name":"max_time","doc":null,"default_value":"DefaultTimeout","external_name":"max_time","restriction":""}],"double_splat":null,"splat_index":null,"yields":1,"block_arg":{"name":"fn","doc":null,"default_value":"","external_name":"fn","restriction":"(T -> T)"},"return_type":"Result","visibility":"Public","body":"select\nwhen @commands.send(Update.new(fn))\n  Result::Submitted\nwhen timeout(max_time)\n  Result::Timeout\nend\n"}}],"macros":[],"types":[{"html_id":"/Agent/Result","path":"Agent/Result.html","kind":"enum","full_name":"Agent::Result","name":"Result","abstract":false,"superclass":null,"ancestors":[{"html_id":"/Enum","kind":"struct","full_name":"Enum","name":"Enum"},{"html_id":"/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"","program":false,"enum":true,"alias":false,"aliased":"","const":false,"constants":[{"id":"Timeout","name":"Timeout","value":"0","doc":null,"summary":null},{"id":"Submitted","name":"Submitted","value":"1","doc":null,"summary":null},{"id":"Error","name":"Error","value":"2","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"/Agent","kind":"class","full_name":"Agent(T)","name":"Agent"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[{"id":"error?-instance-method","html_id":"error?-instance-method","name":"error?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":null,"def":{"name":"error?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == Error"}},{"id":"submitted?-instance-method","html_id":"submitted?-instance-method","name":"submitted?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":null,"def":{"name":"submitted?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == Submitted"}},{"id":"timeout?-instance-method","html_id":"timeout?-instance-method","name":"timeout?","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":null,"def":{"name":"timeout?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self == Timeout"}}],"macros":[],"types":[]},{"html_id":"/Agent/Update","path":"Agent/Update.html","kind":"struct","full_name":"Agent::Update(T)","name":"Update","abstract":false,"superclass":{"html_id":"/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"/Agent","kind":"class","full_name":"Agent(T)","name":"Agent"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(fn:T->T)-class-method","html_id":"new(fn:T-&gt;T)-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"fn","doc":null,"default_value":"","external_name":"fn","restriction":"(T -> T)"}],"args_string":"(fn : T -> T)","source_link":null,"def":{"name":"new","args":[{"name":"fn","doc":null,"default_value":"","external_name":"fn","restriction":"(T -> T)"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = Update(T).allocate\n_.initialize(fn)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"clone-instance-method","html_id":"clone-instance-method","name":"clone","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":null,"def":{"name":"clone","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.new(@fn.clone)"}},{"id":"copy_with(fn_fn=@fn)-instance-method","html_id":"copy_with(fn_fn=@fn)-instance-method","name":"copy_with","doc":null,"summary":null,"abstract":false,"args":[{"name":"_fn","doc":null,"default_value":"@fn","external_name":"fn","restriction":""}],"args_string":"(fn _fn = @fn)","source_link":null,"def":{"name":"copy_with","args":[{"name":"_fn","doc":null,"default_value":"@fn","external_name":"fn","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.new(_fn)"}},{"id":"fn:T->T-instance-method","html_id":"fn:T-&gt;T-instance-method","name":"fn","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : T -> T","source_link":null,"def":{"name":"fn","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"(T -> T)","visibility":"Public","body":"@fn"}}],"macros":[],"types":[]},{"html_id":"/Agent/Wait","path":"Agent/Wait.html","kind":"struct","full_name":"Agent::Wait","name":"Wait","abstract":false,"superclass":{"html_id":"/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[],"repository_name":"","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"/Agent","kind":"class","full_name":"Agent(T)","name":"Agent"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(ack:Channel(Nil))-class-method","html_id":"new(ack:Channel(Nil))-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"ack","doc":null,"default_value":"","external_name":"ack","restriction":"Channel(Nil)"}],"args_string":"(ack : Channel(Nil))","source_link":null,"def":{"name":"new","args":[{"name":"ack","doc":null,"default_value":"","external_name":"ack","restriction":"Channel(Nil)"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(ack)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"ack:Channel(Nil)-instance-method","html_id":"ack:Channel(Nil)-instance-method","name":"ack","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Channel(Nil)","source_link":null,"def":{"name":"ack","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Channel(Nil)","visibility":"Public","body":"@ack"}},{"id":"clone-instance-method","html_id":"clone-instance-method","name":"clone","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":null,"def":{"name":"clone","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.new(@ack.clone)"}},{"id":"copy_with(ack_ack=@ack)-instance-method","html_id":"copy_with(ack_ack=@ack)-instance-method","name":"copy_with","doc":null,"summary":null,"abstract":false,"args":[{"name":"_ack","doc":null,"default_value":"@ack","external_name":"ack","restriction":""}],"args_string":"(ack _ack = @ack)","source_link":null,"def":{"name":"copy_with","args":[{"name":"_ack","doc":null,"default_value":"@ack","external_name":"ack","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.new(_ack)"}}],"macros":[],"types":[]}]}]}})